# -- Number of controller replicas. Only one replica holds the leader lock
# at a time; additional replicas provide fast failover.
replicaCount: 1

# -- Controller container image configuration.
image:
  # -- Image repository for the controller manager.
  repository: ghcr.io/ia-eknorr/stoker-operator
  # -- Image tag. Defaults to the chart's appVersion if empty.
  tag: ""
  # -- Image pull policy (Always, IfNotPresent, Never).
  pullPolicy: IfNotPresent

# -- Agent sidecar image injected into gateway pods by the webhook.
agentImage:
  # -- Image repository for the sync agent sidecar.
  repository: ghcr.io/ia-eknorr/stoker-agent
  # -- Image tag. Defaults to the chart's appVersion if empty.
  tag: ""

# -- Credentials for private container registries.
# Example:
#   imagePullSecrets:
#     - name: my-registry-secret
imagePullSecrets: []

# -- Override the chart name used in resource names.
nameOverride: ""
# -- Override the full release name used in resource names.
fullnameOverride: ""

# -- CPU and memory resource requests/limits for the controller container.
# The controller runs git ls-remote (no clone) and watches CRs, so resource
# requirements are modest.
resources:
  limits:
    cpu: 500m
    memory: 128Mi
  requests:
    cpu: 10m
    memory: 64Mi

# -- Leader election prevents multiple controller instances from reconciling
# simultaneously. Disable only for single-replica development setups.
leaderElection:
  # -- Enable leader election for controller manager.
  enabled: true

# -- Metrics endpoint configuration. The controller exposes Prometheus metrics
# over HTTPS on the metrics service port.
metrics:
  # -- Enable the metrics Service.
  enabled: true
  service:
    # -- Port the metrics service listens on.
    port: 8443
    # -- Service type for the metrics endpoint.
    type: ClusterIP

# -- Prometheus ServiceMonitor for automatic scrape target discovery.
# Requires the prometheus-operator CRDs to be installed in the cluster.
serviceMonitor:
  # -- Create a ServiceMonitor resource.
  enabled: false
  # -- Additional labels for the ServiceMonitor (e.g. for Prometheus selector matching).
  labels: {}
  # -- Scrape interval. Falls back to the Prometheus default if empty.
  interval: ""
  # -- Scrape timeout. Falls back to the Prometheus default if empty.
  scrapeTimeout: ""

# -- PodMonitor for scraping agent sidecar metrics across all namespaces.
# Requires the prometheus-operator CRDs to be installed in the cluster.
podMonitor:
  # -- Create a PodMonitor resource for agent sidecars.
  enabled: false
  # -- Additional labels for the PodMonitor (e.g. for Prometheus selector matching).
  labels: {}
  # -- Scrape interval. Falls back to the Prometheus default if empty.
  interval: ""
  # -- Scrape timeout. Falls back to the Prometheus default if empty.
  scrapeTimeout: ""

# -- PrometheusRule for Stoker alerting rules.
# Requires the prometheus-operator CRDs to be installed in the cluster.
prometheusRule:
  # -- Create a PrometheusRule resource with default alerts.
  enabled: false
  # -- Additional labels for the PrometheusRule.
  labels: {}
  # -- Additional alerting rules appended to the default set.
  additionalRules: []

# -- Grafana dashboard provisioning via sidecar auto-discovery.
# Creates a ConfigMap labeled `grafana_dashboard: "1"` that the Grafana sidecar
# (k8s-sidecar) detects and provisions automatically. This is the standard
# pattern used by kube-prometheus-stack and does not affect existing dashboards.
# If your Grafana instance does not use the sidecar, you can import the dashboard
# JSON manually from charts/stoker-operator/dashboards/stoker-overview.json.
grafanaDashboard:
  # -- Create a ConfigMap containing the Stoker Grafana dashboard.
  # Enable when your Grafana uses the k8s-sidecar for dashboard auto-discovery
  # (default in kube-prometheus-stack).
  enabled: false
  # -- Namespace for the dashboard ConfigMap. Defaults to the release namespace.
  # Set this to your Grafana namespace if the sidecar only watches a specific namespace.
  namespace: ""
  # -- Additional labels for the dashboard ConfigMap.
  # Override if your sidecar uses a label other than `grafana_dashboard: "1"`.
  labels: {}
  # -- Annotations for the dashboard ConfigMap.
  annotations: {}

# -- NetworkPolicy restricts ingress to the metrics port. Only allows traffic
# from namespaces labeled `metrics: enabled`.
networkPolicy:
  # -- Create a NetworkPolicy for the controller.
  enabled: false

# -- Mutating webhook for sidecar injection. When enabled, pods with annotation
# `stoker.io/inject: "true"` get the stoker-agent sidecar injected automatically.
# By default, injection works in all namespaces except kube-system and kube-node-lease.
webhook:
  # -- Enable the MutatingWebhookConfiguration and webhook Service.
  enabled: true
  # -- Webhook server port on the controller container.
  port: 9443
  namespaceSelector:
    # -- Require the stoker.io/injection=enabled label on namespaces
    # for sidecar injection. When false (default), the webhook intercepts
    # pod creates in all namespaces except kube-system and kube-node-lease.
    # Enable for regulated environments that require explicit namespace opt-in.
    requireLabel: false

# -- RBAC configuration for the agent sidecar.
rbac:
  autoBindAgent:
    # -- Automatically create RoleBindings for the agent sidecar in namespaces
    # where GatewaySync CRs exist. The controller discovers ServiceAccounts from
    # gateway pods and binds only those SAs to the stoker-agent ClusterRole.
    # Disable for environments that manage RBAC externally (e.g., GitOps-managed RBAC).
    enabled: true

# -- cert-manager integration for webhook TLS certificates.
# Requires cert-manager to be installed in the cluster.
certManager:
  # -- Create a self-signed Issuer and Certificate for webhook TLS.
  # Requires cert-manager to be installed in the cluster.
  enabled: true

# -- Git webhook receiver for push-event-driven sync.
# Disabled by default â€” enable when you want push-event-driven syncs.
# When disabled, the controller does not start the HTTP receiver server.
# When enabled without HMAC, any network client that can reach the Service
# can trigger a reconcile. Configure hmac for production use.
webhookReceiver:
  # -- Enable the webhook receiver HTTP server and its Service.
  enabled: false
  # -- Port for the inbound git webhook receiver.
  port: 9444
  # -- HMAC secret for validating webhook signatures (X-Hub-Signature-256).
  # Provide either a literal value or a reference to an existing Secret.
  hmac:
    # -- HMAC secret value. Ignored if secretRef is set.
    secret: ""
    # -- Reference to an existing Secret containing the HMAC key.
    secretRef:
      # -- Name of the Secret.
      name: ""
      # -- Key within the Secret.
      key: "webhook-secret"
  # -- Static bearer token for authenticating webhook requests.
  # Kargo and other callers that cannot compute HMAC signatures should use this.
  # If both token and hmac are configured, either method can authorize a request.
  token:
    # -- Bearer token value. Ignored if secretRef is set.
    secret: ""
    # -- Reference to an existing Secret containing the bearer token.
    secretRef:
      # -- Name of the Secret.
      name: ""
      # -- Key within the Secret.
      key: "webhook-token"
  # -- Ingress for the webhook receiver. Exposes the receiver outside the cluster
  # for push-event-driven syncs from Kargo, GitHub, or other external systems.
  ingress:
    # -- Create an Ingress resource for the webhook receiver.
    enabled: false
    # -- Ingress class name (e.g. "nginx", "traefik", "alb").
    # When empty, the cluster default ingress class is used.
    ingressClassName: ""
    # -- Annotations for the Ingress resource. Use to configure your ingress
    # controller or attach a cert-manager certificate.
    # Example (AWS ALB internal):
    #   kubernetes.io/ingress.class: alb
    #   alb.ingress.kubernetes.io/scheme: internal
    #   alb.ingress.kubernetes.io/group.name: my-group
    #   alb.ingress.kubernetes.io/target-type: ip
    # Example (nginx + cert-manager):
    #   cert-manager.io/cluster-issuer: letsencrypt-prod
    #   nginx.ingress.kubernetes.io/ssl-redirect: "true"
    annotations: {}
    # -- Hosts and paths to expose. At least one host is required when enabled.
    # Example:
    #   - host: stoker.example.com
    #     paths:
    #       - path: /webhook
    #         pathType: Prefix
    hosts: []
    # -- TLS configuration. Omit to rely on ingress controller defaults or
    # cert-manager annotations.
    # Example:
    #   - secretName: stoker-webhook-tls
    #     hosts:
    #       - stoker.example.com
    tls: []

# -- Additional annotations to add to the controller pod.
podAnnotations: {}

# -- Additional labels to add to the controller pod.
podLabels: {}

# -- Node selector labels for scheduling the controller pod.
# Example:
#   nodeSelector:
#     kubernetes.io/os: linux
nodeSelector: {}

# -- Tolerations for scheduling the controller pod on tainted nodes.
tolerations: []

# -- Affinity rules for scheduling the controller pod.
affinity: {}
